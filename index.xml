<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>GeoB99's Homepage on GeoB99 Website</title><link>https://sigwait.github.io/GeoB99.github.io/</link><description>Recent content in GeoB99's Homepage on GeoB99 Website</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Sun, 05 Dec 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://sigwait.github.io/GeoB99.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Introduction to the NT kernel development - Security Manager (Access Tokens - Part 4.1)</title><link>https://sigwait.github.io/GeoB99.github.io/pages/nt-internals-part-4/</link><pubDate>Sun, 05 Dec 2021 00:00:00 +0000</pubDate><guid>https://sigwait.github.io/GeoB99.github.io/pages/nt-internals-part-4/</guid><description>Introduction A user logs into the computer typing their credentials, performs day to day life tasks like surfing the web, play video games, write mails, do work related stuff and whatnot. Sometimes it might have happened that a user has to do certain tasks that only can be done in an elevated process, or that is, a user temporarily acquires privilege elevation to perform such tasks until the job is done.</description></item><item><title>Introduction to the NT kernel development (Part 3)</title><link>https://sigwait.github.io/GeoB99.github.io/pages/nt-internals-part-3/</link><pubDate>Tue, 01 Jun 2021 00:00:00 +0000</pubDate><guid>https://sigwait.github.io/GeoB99.github.io/pages/nt-internals-part-3/</guid><description>Introduction In the previous chapters I have shown and explained some of the theoretical aspects of the NT kernel, its design and first and foremost, the concept behind the &amp;ldquo;Executive&amp;rdquo; that rules the kernel and its microkernel-ish foundation. In this chapter of &amp;ldquo;Introduction to the NT kernel development&amp;rdquo; we&amp;rsquo;ll now be focusing on how to write code for the kernel for the first time, compiling it, debugging it and whatnot. In the future chapters we&amp;rsquo;ll be focusing on each subsystem of the kernel individually piece by piece of the Executive, their specific purpose, how to code and act accordingly to them, reverse engineering tips and such.</description></item><item><title>Introduction to the NT kernel development (Part 2)</title><link>https://sigwait.github.io/GeoB99.github.io/pages/nt-internals-part-2/</link><pubDate>Sat, 08 May 2021 00:00:00 +0000</pubDate><guid>https://sigwait.github.io/GeoB99.github.io/pages/nt-internals-part-2/</guid><description>In this chapter we&amp;rsquo;ll cover some further topics about the NT kernel, namely the system calls interface in NT, the basic data types used, function conventions and syntax topology of the prefix routines and the startup and shutdown mechanism procedure of the kernel.
Topology of the routine prefixes in the NT kernel The more you explore around the kernel you may find a plethora of functions across different components of the kernel that adhere to a set of rules regarding function prefixing.</description></item><item><title>Introduction to the NT kernel development (Part 1)</title><link>https://sigwait.github.io/GeoB99.github.io/pages/nt-internals-part-1/</link><pubDate>Sat, 01 May 2021 00:00:00 +0000</pubDate><guid>https://sigwait.github.io/GeoB99.github.io/pages/nt-internals-part-1/</guid><description>Introduction &amp;ldquo;Introduction to the NT kernel development&amp;rdquo; is a collection of articles and guidelines for novice people who know coding and OS development but are unfamiliar with the tenets of NT and its principles. Such collection covers theoretical aspects, focusing primarily on the internal specifications and their purpose of the kernel, the overall infrastructure of the kernel, rules and remarks to be addressed whilst contributing for the NT kernel as well as advanced programming topics and whatnot.</description></item><item><title>Writing your first APITEST testcase</title><link>https://sigwait.github.io/GeoB99.github.io/pages/write-apitest/</link><pubDate>Mon, 01 Mar 2021 00:00:00 +0000</pubDate><guid>https://sigwait.github.io/GeoB99.github.io/pages/write-apitest/</guid><description>Introduction In this tutorial I&amp;rsquo;ll show you how to write a testcase for specific function APIs, understanding the typology of API tests, compiling the testcase as well as analysing the results of the executed tests. This article only covers the APITESTs section of the ReactOS Tests infrastructure, the rest like kernel tests (KMTEST), driver or DIB tests aren&amp;rsquo;t taken into account!
What is a testcase? As ReactOS aims to be a compatible operating system with the NT architecture both in internal implementation as well as in API specifications, conducting research is one of the fundamental aspects within the ReactOS development.</description></item><item><title>How to translate the 1st stage setup component</title><link>https://sigwait.github.io/GeoB99.github.io/pages/usetup-translate/</link><pubDate>Wed, 10 Feb 2021 00:00:00 +0000</pubDate><guid>https://sigwait.github.io/GeoB99.github.io/pages/usetup-translate/</guid><description>Introduction What you&amp;rsquo;ve learnt in the past is how to translate ReactOS (built-in applications, DLLs, et al) by interacting with resource files of the project, however, translating the 1st stage setup component (or internally named as USETUP) is quite different from the general way of translating the project in your language. With that said, in this tutorial I&amp;rsquo;ll be showing you how to translate USETUP and compile the translation.
MUI design in USETUP What makes the translation between other ReactOS modules and USETUP different is the MUI (Multilingual User Interface) internal implementation differences.</description></item><item><title>Writing your first basic built-in program for ReactOS</title><link>https://sigwait.github.io/GeoB99.github.io/pages/write-built-in-program/</link><pubDate>Tue, 12 Jan 2021 00:00:00 +0000</pubDate><guid>https://sigwait.github.io/GeoB99.github.io/pages/write-built-in-program/</guid><description>Introduction In this article I&amp;rsquo;ll show you how to write the very basic buit-in program for ReactOS. This article only covers the basic aspects, the overall directory structure of the program and how to compile it later using RosBE so that you can familiarise with the ReactOS user mode applications development workflow.
Before we get started, I&amp;rsquo;m going to explain what is a built-in program within the context of the article and what is explained here.</description></item><item><title>Understanding Blue Screens of Death (Part 2)</title><link>https://sigwait.github.io/GeoB99.github.io/pages/blue-screen-2/</link><pubDate>Mon, 28 Dec 2020 00:00:00 +0000</pubDate><guid>https://sigwait.github.io/GeoB99.github.io/pages/blue-screen-2/</guid><description>In the part 1 of the article I&amp;rsquo;ve discussed what&amp;rsquo;s a blue screen, the contents and their meaning behind a blue screen, how a blue screen works internally and finally what are the differences between Windows 9x and NT blue screen internal implementation. And now, in this article I&amp;rsquo;ll cover the baisc techniques to troubleshoot a bugcheck using WinDBG and how to read a memory crash dump.
Troubleshoot a bugcheck with WinDBG WinDBG is a powerful tool for debugging PE (Portable Executable) files, namely executable process ones (file extension being .</description></item><item><title>Understanding Blue Screens of Death (Part 1)</title><link>https://sigwait.github.io/GeoB99.github.io/pages/blue-screen/</link><pubDate>Sat, 26 Dec 2020 00:00:00 +0000</pubDate><guid>https://sigwait.github.io/GeoB99.github.io/pages/blue-screen/</guid><description>Introduction Ahh, those blue screens. Everybody hates them and so do you. Especially when you&amp;rsquo;re in the middle of something, like doing important work and out of a sudden a BSoD pops up leaving all of your unsaved work lost forever. It&amp;rsquo;s so frustrating, isn&amp;rsquo;t it? Despite this, Windows (and ReactOS as well) have multitude of reasons why the system has to be brought to a crash and in this article I&amp;rsquo;ll cover the general tenets and aspects of the blue screen.</description></item><item><title>How to compile ReactOS using RosBE (Windows)</title><link>https://sigwait.github.io/GeoB99.github.io/pages/reactos-build-gcc/</link><pubDate>Mon, 15 Jun 2020 00:00:00 +0000</pubDate><guid>https://sigwait.github.io/GeoB99.github.io/pages/reactos-build-gcc/</guid><description>Getting the ReactOS Build Environment What is RosBE? ReactOS Build Environment (or RosBE by its acronym) is a software environment consisting of a compiler, GCC (GNU C Compiler), and various tools to compile ReactOS. RosBE is both ported for GNU/Linux and MacOS environments and it can be used to build standalone modules or applications as well without having to build the whole operating system (which I will explain later). In this tutorial I only take into account how to build ReactOS within Windows platform!</description></item><item><title>Contribute to ReactOS with your first patch</title><link>https://sigwait.github.io/GeoB99.github.io/pages/reactos-contributing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sigwait.github.io/GeoB99.github.io/pages/reactos-contributing/</guid><description>Git Workflow Understanding the Git workflow The Git workflow is the fundamental principle and the inner design of how Git operates with control verioning in a project development. In essence, with Git it goes by committing changes, creating or pushing Pull Requests (with PR as abbreviation) and among other stuff like tagging and setting up releases. Although to contribute to ReactOS we only care about how to create a PR for our patches.</description></item><item><title>First time Git setup</title><link>https://sigwait.github.io/GeoB99.github.io/pages/first-setup-git/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sigwait.github.io/GeoB99.github.io/pages/first-setup-git/</guid><description>Git SCM installation Brief Introduction Git is a powerful distributed version control (DVC) software used for tracking development workflow of a project. It provides a full-fledged tracking history and Git is generally easy to use. As the ReactOS project infrastructure relies on Git for software development and patch contributions, this tutorial aims primarly on how to install Git SCM and do a basic user configuration.
NOTE: Git SCM is a Git utility that uses CLI (command line interface) as the primary UI for Git interactions.</description></item><item><title>How to translate ReactOS</title><link>https://sigwait.github.io/GeoB99.github.io/pages/reactos-translate/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sigwait.github.io/GeoB99.github.io/pages/reactos-translate/</guid><description>Understanding resource files (.rc) What is a resource file? Windows and ReactOS can be localized through forms of resources files, with .rc as file extension. Resource files are implemented through MUI technology which makes it possible for the operating system to be localized in various languages across the globe. A resource file is like a file script that composes the general graphical infrastructure of a program in Windows/ReactOS, that is, menus, dialog templates, windows, icons, bitmaps and static control texts for instance.</description></item><item><title>NTDLL Tree</title><link>https://sigwait.github.io/GeoB99.github.io/doc/ntdll-tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sigwait.github.io/GeoB99.github.io/doc/ntdll-tree/</guid><description>Native API user-mode layer (NTDLL) layout source tree The Native API, serving the purpose as a system call interface for subsystem environments, provides the Rtl section known as the Run-Time library as well as Loader and SxS (Side-by-Side Assembly) module source codes. The base library service of the Windows subsystem, Kernel32.dll, makes a call into NTDLL which in turn invokes a specific kernel mode service in the NT kernel to accomplish a request.</description></item><item><title>ntoskrnl tree</title><link>https://sigwait.github.io/GeoB99.github.io/doc/ntoskrnl/tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sigwait.github.io/GeoB99.github.io/doc/ntoskrnl/tree/</guid><description>## Windows Server 2003 kernel source tree
What you&amp;rsquo;re seeing here is the NT kernel source tree layout of Windows Server 2003 (Service Pack 2). The source layout of Windows Server 2003 kernel is structured in a directory called ntos whereas base serves as the base operating system directory of Windows as a whole. You may wonder though, how did I obtain the said source layout of the NT kernel?</description></item><item><title>PsChangeJobMemoryUsage</title><link>https://sigwait.github.io/GeoB99.github.io/doc/ntoskrnl/ps/job/pschangejobmemoryusage/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sigwait.github.io/GeoB99.github.io/doc/ntoskrnl/ps/job/pschangejobmemoryusage/</guid><description>PsChangeJobMemoryUsage Description This function changes the memory usage of a specific process Executive job.
Internals &amp;amp; Parameters BOOLEAN NTAPI PsChangeJobMemoryUsage( IN ULONG Constant, IN SSIZE\_T UsageAmount) Constant is a parameter that must be set with a constant value of 10 (0x00000010) with the behaviour of this constant being discovered in Windows Server 2003. Currently it&amp;rsquo;s yet to be understood what is the purpose of this parameter and what is it needed for.</description></item><item><title>PspRemoveProcessFromJob</title><link>https://sigwait.github.io/GeoB99.github.io/doc/ntoskrnl/ps/job/pspremoveprocessfromjob/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sigwait.github.io/GeoB99.github.io/doc/ntoskrnl/ps/job/pspremoveprocessfromjob/</guid><description>PspRemoveProcessFromJob Description The function removes a process executive object from a job.
Internals &amp;amp; Parameters VOID NTAPI PspRemoveProcessFromJob( IN PEPROCESS Process, IN PEJOB Job) Process is a pointer to a Executive Process structure (EPROCESS). The first argument parameter is compulsory as it&amp;rsquo;s needed to specify a process to be removed from a job, it mustn&amp;rsquo;t be NULL. Job is a pointer to a Executive Job structure (EJOB). As with the second parameter, the caller is expected to pass a valid job object to the callee function service.</description></item><item><title>Understanding the ReactOS source tree</title><link>https://sigwait.github.io/GeoB99.github.io/pages/reactos-source-tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sigwait.github.io/GeoB99.github.io/pages/reactos-source-tree/</guid><description>ReactOS source tree structure Poking through the ReactOS repository source tree it might intimidate you by the fact that ReactOS repository infrastructure is a behemoth in size with every directory serving own purpose. Fear not as in this tutorial I&amp;rsquo;ll be explaining the structure of ReactOS source tree for an ease navigation through the repository.
ReactOS source tree directories .github &amp;ndash; Primary GitHub directory of the repository. It contains the workflow file configuration as well as the PR management and funding document.</description></item><item><title>User32 Tree</title><link>https://sigwait.github.io/GeoB99.github.io/doc/user32-tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sigwait.github.io/GeoB99.github.io/doc/user32-tree/</guid><description>User32 user-mode library layout tree User32.dll is a user mode DLL library that provides windowing manager APIs to the client. An example of a call brought by the said library is CreateWindowExW which creates a window with extended styles. The documented function calls in the User32.dll library rely on undocumented internal functions in Win32k, the kernel mode side of the Windows subsystem.
d: nt windows (Windows Subsystem) core (Core Windows Kernel Subsystem) ntuser (Native USER Window Manager) client (USER user-mode library) acons.</description></item><item><title>Win32K Tree</title><link>https://sigwait.github.io/GeoB99.github.io/doc/win32k-tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sigwait.github.io/GeoB99.github.io/doc/win32k-tree/</guid><description>Windows Subsystem Kernel layout tree The Windows subsystem environment is divided amongst two chunks that make up the entirety of the said subsystem. The user mode, with client libraries used by applications and components that interact within the user mode space (Kernel32.dll, Gdi32.dll, User32.dll et al) and a large portion being the kernel mode. The latter portion is in itself left undocumented, with no major details or explanation provided about the inner implementation of the kernel mode side.</description></item><item><title>Winsrv layout tree</title><link>https://sigwait.github.io/GeoB99.github.io/doc/winsrv-tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sigwait.github.io/GeoB99.github.io/doc/winsrv-tree/</guid><description>Windows USER + Console server library layout tree Nothing much has to be said about this library. Winsrv.dll is all but a provider for server intercommunication support for console and window manager environment. That is, the server being the kernel mode realm of the Windows subsystem environment (as usual Winsrv.dll relies on Win32k). Speaking of the window manager environment, some fundamental aspects of Winsrv.dll are the hard-error implementation, shutdown/logout notification mechanism and windowing message communication.</description></item></channel></rss>