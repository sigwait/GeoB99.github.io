<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>ReactOS Tutorials on GeoB99 Website</title><link>https://sigwait.github.io/GeoB99.github.io/ros-tutorials/</link><description>Recent content in ReactOS Tutorials on GeoB99 Website</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Sun, 05 Dec 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://sigwait.github.io/GeoB99.github.io/ros-tutorials/index.xml" rel="self" type="application/rss+xml"/><item><title>Introduction to the NT kernel development - Security Manager (Access Tokens - Part 4.1)</title><link>https://sigwait.github.io/GeoB99.github.io/pages/nt-internals-part-4/</link><pubDate>Sun, 05 Dec 2021 00:00:00 +0000</pubDate><guid>https://sigwait.github.io/GeoB99.github.io/pages/nt-internals-part-4/</guid><description>Introduction A user logs into the computer typing their credentials, performs day to day life tasks like surfing the web, play video games, write mails, do work related stuff and whatnot. Sometimes it might have happened that a user has to do certain tasks that only can be done in an elevated process, or that is, a user temporarily acquires privilege elevation to perform such tasks until the job is done.</description></item><item><title>Introduction to the NT kernel development (Part 3)</title><link>https://sigwait.github.io/GeoB99.github.io/pages/nt-internals-part-3/</link><pubDate>Tue, 01 Jun 2021 00:00:00 +0000</pubDate><guid>https://sigwait.github.io/GeoB99.github.io/pages/nt-internals-part-3/</guid><description>Introduction In the previous chapters I have shown and explained some of the theoretical aspects of the NT kernel, its design and first and foremost, the concept behind the &amp;ldquo;Executive&amp;rdquo; that rules the kernel and its microkernel-ish foundation. In this chapter of &amp;ldquo;Introduction to the NT kernel development&amp;rdquo; we&amp;rsquo;ll now be focusing on how to write code for the kernel for the first time, compiling it, debugging it and whatnot. In the future chapters we&amp;rsquo;ll be focusing on each subsystem of the kernel individually piece by piece of the Executive, their specific purpose, how to code and act accordingly to them, reverse engineering tips and such.</description></item><item><title>Introduction to the NT kernel development (Part 2)</title><link>https://sigwait.github.io/GeoB99.github.io/pages/nt-internals-part-2/</link><pubDate>Sat, 08 May 2021 00:00:00 +0000</pubDate><guid>https://sigwait.github.io/GeoB99.github.io/pages/nt-internals-part-2/</guid><description>In this chapter we&amp;rsquo;ll cover some further topics about the NT kernel, namely the system calls interface in NT, the basic data types used, function conventions and syntax topology of the prefix routines and the startup and shutdown mechanism procedure of the kernel.
Topology of the routine prefixes in the NT kernel The more you explore around the kernel you may find a plethora of functions across different components of the kernel that adhere to a set of rules regarding function prefixing.</description></item><item><title>Introduction to the NT kernel development (Part 1)</title><link>https://sigwait.github.io/GeoB99.github.io/pages/nt-internals-part-1/</link><pubDate>Sat, 01 May 2021 00:00:00 +0000</pubDate><guid>https://sigwait.github.io/GeoB99.github.io/pages/nt-internals-part-1/</guid><description>Introduction &amp;ldquo;Introduction to the NT kernel development&amp;rdquo; is a collection of articles and guidelines for novice people who know coding and OS development but are unfamiliar with the tenets of NT and its principles. Such collection covers theoretical aspects, focusing primarily on the internal specifications and their purpose of the kernel, the overall infrastructure of the kernel, rules and remarks to be addressed whilst contributing for the NT kernel as well as advanced programming topics and whatnot.</description></item><item><title>Writing your first APITEST testcase</title><link>https://sigwait.github.io/GeoB99.github.io/pages/write-apitest/</link><pubDate>Mon, 01 Mar 2021 00:00:00 +0000</pubDate><guid>https://sigwait.github.io/GeoB99.github.io/pages/write-apitest/</guid><description>Introduction In this tutorial I&amp;rsquo;ll show you how to write a testcase for specific function APIs, understanding the typology of API tests, compiling the testcase as well as analysing the results of the executed tests. This article only covers the APITESTs section of the ReactOS Tests infrastructure, the rest like kernel tests (KMTEST), driver or DIB tests aren&amp;rsquo;t taken into account!
What is a testcase? As ReactOS aims to be a compatible operating system with the NT architecture both in internal implementation as well as in API specifications, conducting research is one of the fundamental aspects within the ReactOS development.</description></item><item><title>How to translate the 1st stage setup component</title><link>https://sigwait.github.io/GeoB99.github.io/pages/usetup-translate/</link><pubDate>Wed, 10 Feb 2021 00:00:00 +0000</pubDate><guid>https://sigwait.github.io/GeoB99.github.io/pages/usetup-translate/</guid><description>Introduction What you&amp;rsquo;ve learnt in the past is how to translate ReactOS (built-in applications, DLLs, et al) by interacting with resource files of the project, however, translating the 1st stage setup component (or internally named as USETUP) is quite different from the general way of translating the project in your language. With that said, in this tutorial I&amp;rsquo;ll be showing you how to translate USETUP and compile the translation.
MUI design in USETUP What makes the translation between other ReactOS modules and USETUP different is the MUI (Multilingual User Interface) internal implementation differences.</description></item><item><title/><link>https://sigwait.github.io/GeoB99.github.io/pages/write-built-in-program/</link><pubDate>Tue, 12 Jan 2021 00:00:00 +0000</pubDate><guid>https://sigwait.github.io/GeoB99.github.io/pages/write-built-in-program/</guid><description/></item><item><title>Understanding Blue Screens of Death (Part 2)</title><link>https://sigwait.github.io/GeoB99.github.io/pages/blue-screen-2/</link><pubDate>Mon, 28 Dec 2020 00:00:00 +0000</pubDate><guid>https://sigwait.github.io/GeoB99.github.io/pages/blue-screen-2/</guid><description>In the part 1 of the article I&amp;rsquo;ve discussed what&amp;rsquo;s a blue screen, the contents and their meaning behind a blue screen, how a blue screen works internally and finally what are the differences between Windows 9x and NT blue screen internal implementation. And now, in this article I&amp;rsquo;ll cover the baisc techniques to troubleshoot a bugcheck using WinDBG and how to read a memory crash dump.
Troubleshoot a bugcheck with WinDBG WinDBG is a powerful tool for debugging PE (Portable Executable) files, namely executable process ones (file extension being .</description></item><item><title>Understanding Blue Screens of Death (Part 1)</title><link>https://sigwait.github.io/GeoB99.github.io/pages/blue-screen/</link><pubDate>Sat, 26 Dec 2020 00:00:00 +0000</pubDate><guid>https://sigwait.github.io/GeoB99.github.io/pages/blue-screen/</guid><description>Introduction Ahh, those blue screens. Everybody hates them and so do you. Especially when you&amp;rsquo;re in the middle of something, like doing important work and out of a sudden a BSoD pops up leaving all of your unsaved work lost forever. It&amp;rsquo;s so frustrating, isn&amp;rsquo;t it? Despite this, Windows (and ReactOS as well) have multitude of reasons why the system has to be brought to a crash and in this article I&amp;rsquo;ll cover the general tenets and aspects of the blue screen.</description></item><item><title>How to compile ReactOS using RosBE (Windows)</title><link>https://sigwait.github.io/GeoB99.github.io/pages/reactos-build-gcc/</link><pubDate>Mon, 15 Jun 2020 00:00:00 +0000</pubDate><guid>https://sigwait.github.io/GeoB99.github.io/pages/reactos-build-gcc/</guid><description>Getting the ReactOS Build Environment What is RosBE? ReactOS Build Environment (or RosBE by its acronym) is a software environment consisting of a compiler, GCC (GNU C Compiler), and various tools to compile ReactOS. RosBE is both ported for GNU/Linux and MacOS environments and it can be used to build standalone modules or applications as well without having to build the whole operating system (which I will explain later). In this tutorial I only take into account how to build ReactOS within Windows platform!</description></item><item><title>Contribute to ReactOS with your first patch</title><link>https://sigwait.github.io/GeoB99.github.io/pages/reactos-contributing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sigwait.github.io/GeoB99.github.io/pages/reactos-contributing/</guid><description>Git Workflow Understanding the Git workflow The Git workflow is the fundamental principle and the inner design of how Git operates with control verioning in a project development. In essence, with Git it goes by committing changes, creating or pushing Pull Requests (with PR as abbreviation) and among other stuff like tagging and setting up releases. Although to contribute to ReactOS we only care about how to create a PR for our patches.</description></item><item><title>First time Git setup</title><link>https://sigwait.github.io/GeoB99.github.io/pages/first-setup-git/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sigwait.github.io/GeoB99.github.io/pages/first-setup-git/</guid><description>Git SCM installation Brief Introduction Git is a powerful distributed version control (DVC) software used for tracking development workflow of a project. It provides a full-fledged tracking history and Git is generally easy to use. As the ReactOS project infrastructure relies on Git for software development and patch contributions, this tutorial aims primarly on how to install Git SCM and do a basic user configuration.
NOTE: Git SCM is a Git utility that uses CLI (command line interface) as the primary UI for Git interactions.</description></item><item><title>How to translate ReactOS</title><link>https://sigwait.github.io/GeoB99.github.io/pages/reactos-translate/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sigwait.github.io/GeoB99.github.io/pages/reactos-translate/</guid><description>Understanding resource files (.rc) What is a resource file? Windows and ReactOS can be localized through forms of resources files, with .rc as file extension. Resource files are implemented through MUI technology which makes it possible for the operating system to be localized in various languages across the globe. A resource file is like a file script that composes the general graphical infrastructure of a program in Windows/ReactOS, that is, menus, dialog templates, windows, icons, bitmaps and static control texts for instance.</description></item><item><title>Understanding the ReactOS source tree</title><link>https://sigwait.github.io/GeoB99.github.io/pages/reactos-source-tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sigwait.github.io/GeoB99.github.io/pages/reactos-source-tree/</guid><description>ReactOS source tree structure Poking through the ReactOS repository source tree it might intimidate you by the fact that ReactOS repository infrastructure is a behemoth in size with every directory serving own purpose. Fear not as in this tutorial I&amp;rsquo;ll be explaining the structure of ReactOS source tree for an ease navigation through the repository.
ReactOS source tree directories .github &amp;ndash; Primary GitHub directory of the repository. It contains the workflow file configuration as well as the PR management and funding document.</description></item></channel></rss>